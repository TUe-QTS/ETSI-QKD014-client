#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define SAE_ID_LENGTH 37

typedef struct ETSI014Client ETSI014Client;

typedef struct KeyBytesBorrow KeyBytesBorrow;

typedef struct KeyBytesProtected KeyBytesProtected;

typedef struct E14_KME_Status {
    char source_kme_id[255];
    char target_kme_id[255];
    char source_sae_id[255];
    char target_sae_id[255];
    uint32_t key_size;
    uint32_t stored_key_count;
    uint32_t max_key_count;
    uint32_t max_key_per_request;
    uint32_t max_key_size;
    uint32_t min_key_size;
    uint32_t max_sae_id_count;
} E14_KME_Status;

typedef struct E14_QKD_Key {
    char uuid[SAE_ID_LENGTH];
    uint32_t key_size;
    const struct KeyBytesProtected *key_bytes_protected;
} E14_QKD_Key;

int e14_new_etsi014_client(const char *host,
                           uint16_t port,
                           const char *cert_path,
                           const char *key_path,
                           const char *server_ca_path,
                           const struct ETSI014Client **etsi014_client,
                           const char **error_str);

int e14_get_status(const struct ETSI014Client *client,
                   const char *target_sae_id,
                   struct E14_KME_Status *status,
                   const char **error_str);

/**
 * If functions returns a 0, the caller must call [`e14_free_etsi014_client`]. Otherwise,
 * the caller must call [`e14_free_error_str`]. Before using a qkd key, the caller must call
 * [`e14_unprotect_qkd_key_bytes`]. After a qkd key is not necessary anymore, the caller must
 * call [`e14_free_qkd_key_bytes`].
 */
int e14_get_keys(const struct ETSI014Client *client,
                 uint32_t key_size_bits,
                 const char *target_sae_id,
                 const char *_additional_target_sae_ids,
                 size_t additional_target_sae_ids_size,
                 uint32_t amount_of_keys,
                 struct E14_QKD_Key *keys,
                 const char **error_str);

/**
 * Documentation of function [`e14_get_keys`] also applies to this function.
 */
int e14_get_keys_by_ids(const struct ETSI014Client *client,
                        const char *target_sae_id,
                        char **key_ids,
                        size_t key_ids_len,
                        struct E14_QKD_Key *keys,
                        const char **error_str);

/**
 * Unprotect memory to allow read and write access to qkd key.
 * To protect the memory again, call [`e14_protect_qkd_key_bytes`] instead.
 * e14_protect_qkd_key_bytes must be called:
 * * immediately after you are done reading/writing to key_bytes.
 * * before calling this function again.
 * * before calling [`e14_free_qkd_key_bytes`].
 */
void e14_unprotect_qkd_key_bytes(const struct KeyBytesProtected *key_bytes_protected,
                                 const struct KeyBytesBorrow **key_bytes_borrow,
                                 const uint8_t **key_bytes);

/**
 * Prevent read and write access to key_bytes.
 */
void e14_protect_qkd_key_bytes(const struct KeyBytesBorrow **borrow,
                               const uint8_t **key_bytes);

/**
 * Will overwrite qkd key and deallocate memory.
 */
void e14_free_qkd_key_bytes(const struct KeyBytesProtected **key_bytes_protected);

void e14_free_error_str(const char **error_str);

void e14_free_etsi014_client(const struct ETSI014Client **client);
